

==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 1:35:05
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 많은 수의 자료를 처리하기 - class
//------------------------------------------------------------
 
#include <iostream>
#include <fstream>
#include <array>
#include <algorithm>
#include "save.h"


// [문제] "int 천개"에는 int 값 1000개가 binary 모드로 4000바이트가 그대로 기록되어있다.
// 메모리로 읽어와라.
// 값이 100보다 작은 것은 모두 몇 개인가 출력하라.

//-------
int main()
//-------
{
	std::ifstream in{ "int 천개", std::ios::binary };

	if (!in) {
		exit(0);
	}

	std::array<int, 1'000> numbers;
	in.read((char*)&numbers, sizeof numbers);

	//알고리즘으로 해결
	//std::count_if(begin, end, predicates);
	int cnt = std::count_if(numbers.begin(), numbers.end(), [](const int& n) {
		return n < 100;
		});

	std::cout << "100보다 작은 숫자 - " << cnt << '\n';

	save("소스.cpp");
}


==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 1:40:14
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은(STACK의 크기를 넘는) Data 처리하기
//------------------------------------------------------------
 
#include <iostream>
#include <array>
#include "save.h"

//-------
int main()
//-------
{
	//컴파일러가 다음 코드를 무시
	std::array<char, 10'000'000> a;



	save("소스.cpp");
}

==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 1:41:11
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은(STACK의 크기를 넘는) Data 처리하기
//------------------------------------------------------------
 
#include <iostream>
#include <array>
#include "save.h"

//-------
int main()
//-------
{
	//컴파일 문제  X
	std::array<char, 10'000'000> a;

	std::cout << a[0] << '\n';
	a[9'000'000] = 123;
	std::cout << a[9'000'000] << '\n';

	save("소스.cpp");
}



==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 1:43:25
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은(STACK의 크기를 넘는) Data 처리하기
//------------------------------------------------------------
 
#include <iostream>
#include <array>
#include "save.h"

//-------
int main()
//-------
{
	//컴파일 문제  X
	std::array<char, 10'000'000> a{ 1, };

	save("소스.cpp");
}

==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 1:43:41
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은(STACK의 크기를 넘는) Data 처리하기
//------------------------------------------------------------
 
#include <iostream>
#include <array>
#include "save.h"

//-------
int main()
//-------
{
	//컴파일 문제  X
	std::array<char, 1'000'000> a;

	int i{};
	for (char& c : a)
		c = ++i;

	for (char c : a)
		std::cout << c << ' ';

	save("소스.cpp");
}

==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 1:48:33
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은(STACK의 크기를 넘는) Data 처리하기
//------------------------------------------------------------
 
#include <iostream>
#include <array>
#include "save.h"

//컴파일 문제  X
std::array<char, 1'000'000'000> a;		//DATA

//-------
int main()
//-------
{
	int i{};
	for (char& c : a)
		c = ++i;

	for (char c : a)
		std::cout << c;

	save("소스.cpp");
}


==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 2:42:48
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당 
//------------------------------------------------------------
#include <iostream>
#include "save.h"

// [문제] 사용자가 원하는 수 만큼 int를 저장할 메모리를 할당하라
// 메모리의 값을 1부터 값을 증가시키며 채워라
// 합계를 화면에 출력하라
// 이 과정을 영원히 반복하라

//-------
int main()
//-------
{

    save("소스.cpp");

    while ( true )
    {
        //'a'를 입력하면 무한 루프를 돈다
        std::cout << "몇 개의 int를 만들까요? ";
        int num;
        std::cin >> num;

        if (num < 0)
        {
            std::cout << "0보다 큰 수를 입력하세요 \n";
            continue;
        }

	  //해당 부분은 C++의 장점을 깎아먹는다.
	  //int* p;
        //try {
        //    p = new int[num];    //시스템에 요청
        //}
        //catch (std::exception& e){
        //    std::cout << "메모리 고갈 - " << e.what() << '\n';
        //    return 0;
        //}

        int* arr = new int[num];  // 시스템에 요청
        for (int i = 0; i < num; ++i)
        {
            arr[i] = i + 1;
        }

	  //int사용시 큰 입력이 주어지면 오버 플로우 발생이 쉬워진다.
        long long sum{};
        for (int i = 0; i < num; ++i)
        {
            sum += arr[i];
        }
        std::cout << "1부터 "<< num << "까지 합계 - " << sum << '\n';

        delete[] p;             // 자원 반환

        // 문제점
        // 소스 코드의 물리적인 거리(new 와 delete)
        // int[] 와 int*(raw-pointer)를 사용하지 말자(원시적) 
    } 

}



==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 3:07:36
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당 
//------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

// [문제] 사용자가 원하는 수 만큼 int를 저장할 메모리를 할당하라
// 메모리의 값을 1부터 값을 증가시키며 채워라
// 합계를 화면에 출력하라
// 이 과정을 영원히 반복하라

//-------
int main()
//-------
{
    save("소스.cpp");
    while ( true )
    {
        int num{ 200'000'000 };     // 800MB

        
        std::unique_ptr<int[]>p{ new int[num] };    // 시스템에 요청

        //int* p = new int[num];

        for (int i = 0; i < num; ++i)
        {
            p[i] = i + 1;
        }

        long long sum{};
        for (int i = 0; i < num; ++i)
        {
            sum += p[i];
        }

        std::cout << "1부터 "<< num << "까지 합계 - " << sum << '\n';
    } 
}


==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 3:12:37
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당 
//------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

// [문제] 스마트 포인터의 동작을 관찰할 수 있도록 class Dog를 사용

class Dog
{
public:
	Dog();
	~Dog();

private:
	char c[100'000'000];
};

Dog::Dog()
{
	std::cout << "Dog 생성" << '\n';
}

Dog::~Dog()
{
	std::cout << "Dog 소멸" << '\n';
}

//-------
int main()
//-------
{
	save("소스.cpp");
	while (true)
	{
		Dog* dog = new Dog[10];    // sizeof(Dog) * 10 = 1GB
	}
}


==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 3:13:13
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당 
//------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

// [문제] 스마트 포인터의 동작을 관찰할 수 있도록 class Dog를 사용

class Dog
{
public:
	Dog();
	~Dog();

private:
	char c[100'000'000];
};

Dog::Dog()
{
	std::cout << "Dog 생성" << '\n';
}

Dog::~Dog()
{
	std::cout << "Dog 소멸" << '\n';
}

//-------
int main()
//-------
{
	save("소스.cpp");
	int cnt{};
	while (true)
	{
		std::cout << ++cnt << '\n';
		Dog* dog = new Dog[10];    // sizeof(Dog) * 10 = 1GB
	}
}


==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 3:13:42
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당 
//------------------------------------------------------------
#include <iostream>
#include <memory>
#include "save.h"

// [문제] 스마트 포인터의 동작을 관찰할 수 있도록 class Dog를 사용

class Dog
{
public:
	Dog();
	~Dog();

private:
	char c[100'000'000];
};

Dog::Dog()
{
	std::cout << "Dog 생성" << '\n';
}

Dog::~Dog()
{
	std::cout << "Dog 소멸" << '\n';
}

//-------
int main()
//-------
{
	save("소스.cpp");
	int cnt{};
	while (true)
	{
		std::cout << ++cnt << '\n';
		Dog* dog = new Dog[10];    // sizeof(Dog) * 10 = 1GB

		delete[] dog;
	}
}


==================================================
소스.cpp , 저장시간: 2023-03-16 목요일 오후 3:16:25
==================================================
//------------------------------------------------------------
// 2023. 3. 16 목56						(3주 1일)
//------------------------------------------------------------
// 더 많은 자료 처리하기 - new를 사용한 메모리 동적할당 
//------------------------------------------------------------
#include <iostream>
#include <memory>
#include <chrono>
#include "save.h"

// [문제] 스마트 포인터의 동작을 관찰할 수 있도록 class Dog를 사용

class Dog
{
public:
	Dog();
	~Dog();

private:
	char c[100'000'000];
};

Dog::Dog()
{
	std::cout << "Dog 생성" << '\n';
}

Dog::~Dog()
{
	std::cout << "Dog 소멸" << '\n';
}

//-------
int main()
//-------
{
	save("소스.cpp");
	int cnt{};
	while (true)
	{
		std::cout << ++cnt << '\n';
		std::unique_ptr<Dog[]> dog{ new Dog[10] };    // sizeof(Dog) * 10 = 1GB

		std::this_thread::sleep_for(std::chrono::milliseconds(1000));
		//std::this_thread::sleep_for(1s); 을 사용하려면 using namespace std;를 사용하고 사용
	}
}
